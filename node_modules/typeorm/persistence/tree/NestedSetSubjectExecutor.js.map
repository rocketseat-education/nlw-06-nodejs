{"version":3,"sources":["../../src/persistence/tree/NestedSetSubjectExecutor.ts"],"names":[],"mappings":"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","file":"NestedSetSubjectExecutor.js","sourcesContent":["import {Subject} from \"../Subject\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {NestedSetMultipleRootError} from \"../../error/NestedSetMultipleRootError\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\n\nclass NestedSetIds {\n    left: number;\n    right: number;\n}\n\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(subject.metadata.tablePath);\n        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn!.databaseName);\n        const rightColumnName = escape(subject.metadata.nestedSetRightColumn!.databaseName);\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n        const parentId = subject.metadata.getEntityIdMap(parent);\n\n        let parentNsRight: number|undefined = undefined;\n        if (parentId) {\n            parentNsRight = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn!.propertyPath, \"right\")\n                .from(subject.metadata.target, subject.metadata.targetName)\n                .whereInIds(parentId)\n                .getRawOne()\n                .then(result => {\n                    const value: any = result ? result[\"right\"] : undefined;\n                    // CockroachDB returns numeric types as string\n                    return typeof value === \"string\" ? parseInt(value) : value;\n                });\n        }\n\n        if (parentNsRight !== undefined) {\n            await this.queryRunner.query(`UPDATE ${tableName} SET ` +\n                `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\n                `${rightColumnName} = ${rightColumnName} + 2 ` +\n                `WHERE ${rightColumnName} >= ${parentNsRight}`);\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(parentNsRight),\n                subject.metadata.nestedSetRightColumn!.createValueMap(parentNsRight + 1),\n            );\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n            \n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot)\n                throw new NestedSetMultipleRootError();\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\n            );\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.entity;\n\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && parent) // if entity was attached via children\n            entity = subject.metadata.treeChildrenRelation!.getEntityValue(parent).find((child: any) => {\n                return Object.entries(subject.identifier!).every(([key, value]) => child[key] === value);\n            });\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return;\n        }\n\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(entity!);\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n        const parentId = subject.metadata.getEntityIdMap(parent);\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return;\n        }\n\n        if (parent) {\n            const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n            const tableName = this.getTableName(subject.metadata.tablePath);\n            const leftColumnName = escape(subject.metadata.nestedSetLeftColumn!.databaseName);\n            const rightColumnName = escape(subject.metadata.nestedSetRightColumn!.databaseName);\n\n            const entityId = subject.metadata.getEntityIdMap(entity);\n\n            let entityNs: NestedSetIds | undefined = undefined;\n            if (entityId) {\n                entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];\n            }\n\n            let parentNs: NestedSetIds | undefined = undefined;\n            if (parentId) {\n                parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];\n            }\n\n            if (entityNs !== undefined && parentNs !== undefined) {\n                const isMovingUp = parentNs.left > entityNs.left;\n                const treeSize = entityNs.right - entityNs.left + 1;\n\n                let entitySize: number;\n                if (isMovingUp) {\n                    entitySize = parentNs.left - entityNs.right;\n                } else {\n                    entitySize = parentNs.right - entityNs.left;\n                }\n                \n                // Moved entity logic\n                const updateLeftSide = \n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\n                        `${leftColumnName} < ${entityNs.right} ` +\n                    `THEN ${leftColumnName} + ${entitySize} `;\n\n                const updateRightSide = \n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\n                        `${rightColumnName} <= ${entityNs.right} ` +\n                    `THEN ${rightColumnName} + ${entitySize} `;\n                \n                // Update the surrounding entities\n                if (isMovingUp) {\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\n                        `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\n                                `${leftColumnName} <= ${parentNs.left} ` +\n                            `THEN ${leftColumnName} - ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                        `END, ` +\n                        `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\n                                `${rightColumnName} < ${parentNs.left} ` +\n                            `THEN ${rightColumnName} - ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                        `END`);\n                } else {\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\n                        `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\n                                `${leftColumnName} > ${parentNs.right} ` +\n                            `THEN ${leftColumnName} + ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                        `END, ` +\n                        `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\n                                `${rightColumnName} >= ${parentNs.right} ` +\n                            `THEN ${rightColumnName} + ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                        `END`);\n                }\n            }\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n            \n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot)\n                throw new NestedSetMultipleRootError();\n        }\n    }\n\n    /**\n    * Executes operations when subject is being removed.\n    */\n    async remove(subjects: Subject|Subject[]): Promise<void> {\n        if (!Array.isArray(subjects))\n            subjects = [subjects];\n\n        const metadata = subjects[0].metadata;\n\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(metadata.tablePath);\n        const leftColumnName = escape(metadata.nestedSetLeftColumn!.databaseName);\n        const rightColumnName = escape(metadata.nestedSetRightColumn!.databaseName);\n\n        let entitiesIds: ObjectLiteral[] = [];\n        for (const subject of subjects) {\n            const entityId = metadata.getEntityIdMap(subject.entity);\n            \n            if (entityId) {\n                entitiesIds.push(entityId);\n            }\n        }\n\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);\n\n        for (const entity of entitiesNs) {\n            const treeSize = entity.right - entity.left + 1;\n\n            await this.queryRunner.query(`UPDATE ${tableName} ` +\n                `SET ${leftColumnName} = CASE ` +\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\n                    `ELSE ${leftColumnName} ` +\n                `END, ` +\n                `${rightColumnName} = CASE ` +\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\n                    `ELSE ${rightColumnName} ` +\n                `END`);\n        }\n    }\n\n    /**\n     * Get the nested set ids for a given entity\n     */\n    protected getNestedSetIds(metadata: EntityMetadata, ids: ObjectLiteral | ObjectLiteral[]): Promise<NestedSetIds[]> {\n        const select = {\n            left: `${metadata.targetName}.${metadata.nestedSetLeftColumn!.propertyPath}`,\n            right: `${metadata.targetName}.${metadata.nestedSetRightColumn!.propertyPath}`\n        };\n\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder();\n\n        Object.entries(select).forEach(([key, value]) => {\n            queryBuilder.addSelect(value, key);\n        });\n\n        return queryBuilder\n            .from(metadata.target, metadata.targetName)\n            .whereInIds(ids)\n            .orderBy(select.right, \"DESC\")\n            .getRawMany()\n            .then(results => {\n                const data: NestedSetIds[] = [];\n\n                for (const result of results) {\n                    const entry: any = {};\n                    for (const key of Object.keys(select)) {\n                        const value = result ? result[key] : undefined;\n\n                        // CockroachDB returns numeric types as string\n                        entry[key] = typeof value === \"string\" ? parseInt(value) : value;\n                    }\n                    data.push(entry);\n                }\n                \n                return data;\n            });\n    }\n\n    private async isUniqueRootEntity(subject: Subject, parent: any): Promise<boolean> {\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(subject.metadata.tablePath);\n        const parameters: any[] = [];\n        const whereCondition = subject.metadata.treeParentRelation!.joinColumns.map(column => {\n            const columnName = escape(column.databaseName);\n            const parameter = column.getEntityValue(parent);\n\n            if (parameter == null) {\n                return `${columnName} IS NULL`;\n            }\n\n            parameters.push(parameter);\n            const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n            return `${columnName} = ${parameterName}`;\n        }).join(\" AND \");\n\n        const countAlias = \"count\";\n        const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters);\n\n        return parseInt(result[0][countAlias]) === 0;\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath.split(\".\")\n            .map(i => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n            }).join(\".\");\n    }\n}"],"sourceRoot":"../.."}