{"version":3,"sources":["../../src/persistence/tree/ClosureSubjectExecutor.ts"],"names":[],"mappings":"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","file":"ClosureSubjectExecutor.js","sourcesContent":["import {Subject} from \"../Subject\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {CannotAttachTreeChildrenEntityError} from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport {DeleteQueryBuilder} from \"../../query-builder/DeleteQueryBuilder\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {SqlServerDriver} from \"../../driver/sqlserver/SqlServerDriver\";\nimport {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\n\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n\n        // create values to be inserted into the closure junction\n        const closureJunctionInsertMap: ObjectLiteral = {};\n        subject.metadata.closureJunctionTable.ancestorColumns.forEach(column => {\n            closureJunctionInsertMap[column.databaseName] = subject.identifier;\n        });\n        subject.metadata.closureJunctionTable.descendantColumns.forEach(column => {\n            closureJunctionInsertMap[column.databaseName] = subject.identifier;\n        });\n\n        // insert values into the closure junction table\n        await this.queryRunner\n            .manager\n            .createQueryBuilder()\n            .insert()\n            .into(subject.metadata.closureJunctionTable.tablePath)\n            .values(closureJunctionInsertMap)\n            .updateEntity(false)\n            .callListeners(false)\n            .execute();\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n\n        if (parent) {\n            const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n            const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n            const queryParams: any[] = [];\n\n            const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n                return escape(column.databaseName);\n            });\n            const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n                return escape(column.databaseName);\n            });\n            const childEntityIds1 = subject.metadata.primaryColumns.map(column => {\n                queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity!));\n                return this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams.length - 1);\n            });\n\n            const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n                const columnName = escape(column.databaseName);\n                const parentId = column.referencedColumn!.getEntityValue(parent);\n\n                if (!parentId)\n                    throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n\n                queryParams.push(parentId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn!.databaseName, queryParams.length - 1);\n                return `${columnName} = ${parameterName}`;\n            });\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` +\n                `SELECT ${ancestorColumnNames.join(\", \")}, ${childEntityIds1.join(\", \")} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`,\n                queryParams\n            );\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.entity;\n\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && parent) // if entity was attached via children\n            entity = subject.metadata.treeChildrenRelation!.getEntityValue(parent).find((child: any) => {\n                return Object.entries(subject.identifier!).every(([key, value]) => child[key] === value);\n            });\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return;\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(entity!);\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n        const parentId = subject.metadata.getEntityIdMap(parent);\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return;\n        }\n\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const closureTable = subject.metadata.closureJunctionTable;\n\n        const ancestorColumnNames = closureTable.ancestorColumns.map(column => {\n            return escape(column.databaseName);\n        });\n\n        const descendantColumnNames = closureTable.descendantColumns.map(column => {\n            return escape(column.databaseName);\n        });\n\n        // Delete logic\n        const createSubQuery = (qb: DeleteQueryBuilder<any>, alias: string) => {\n            const subAlias = `sub${alias}`;\n\n            const subSelect = qb.createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(closureTable.tablePath, subAlias);\n\n            // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n            for (const column of closureTable.ancestorColumns) {\n                subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn!.databaseName}`);\n            }\n\n            return qb.createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(`(${subSelect.getQuery()})`, alias)\n                .setParameters(subSelect.getParameters())\n                .getQuery();\n        };\n\n        const parameters: ObjectLiteral = {};\n        for (const column of subject.metadata.primaryColumns) {\n            parameters[`value_${column.databaseName}`] = entity![column.databaseName];\n        }\n\n        await this.queryRunner\n            .manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(qb => `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(qb, \"descendant\")})`)\n            .andWhere(qb => `(${ancestorColumnNames.join(\", \")}) NOT IN (${createSubQuery(qb, \"ancestor\")})`)\n            .setParameters(parameters)\n            .execute();\n\n        /**\n         * Only insert new parent if it exits\n         * \n         * This only happens if the entity doesn't become a root entity\n         */\n        if (parent) {\n            // Insert logic\n            const queryParams: any[] = [];\n\n            const tableName = this.getTableName(closureTable.tablePath);\n            const superAlias = escape(\"supertree\");\n            const subAlias = escape(\"subtree\");\n\n            const select = [\n                ...ancestorColumnNames.map(columnName => `${superAlias}.${columnName}`),\n                ...descendantColumnNames.map(columnName => `${subAlias}.${columnName}`)\n            ];\n\n            const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n                const columnName = escape(column.databaseName);\n                const entityId = column.referencedColumn!.getEntityValue(entity!);\n\n                queryParams.push(entityId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.referencedColumn!.databaseName, queryParams.length - 1);\n                return `${subAlias}.${columnName} = ${parameterName}`;\n            });\n\n            const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n                const columnName = escape(column.databaseName);\n                const parentId = column.referencedColumn!.getEntityValue(parent);\n\n                if (!parentId)\n                    throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n\n                queryParams.push(parentId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn!.databaseName, queryParams.length - 1);\n                return `${superAlias}.${columnName} = ${parameterName}`;\n            });\n\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` +\n                `SELECT ${select.join(\", \")} ` +\n                `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` +\n                `WHERE ${[...entityWhereCondition, ...parentWhereCondition].join(\" AND \")}`,\n                queryParams\n            );\n        }\n    }\n\n    /**\n    * Executes operations when subject is being removed.\n    */\n    async remove(subjects: Subject|Subject[]): Promise<void> {\n        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n        if (!(this.queryRunner.connection.driver instanceof SqlServerDriver)) {\n            return;\n        }\n\n        if (!Array.isArray(subjects))\n            subjects = [subjects];\n\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const identifiers = subjects.map(subject => subject.identifier);\n        const closureTable = subjects[0].metadata.closureJunctionTable;\n\n        const generateWheres = (columns: ColumnMetadata[]) => {\n            return columns.map(column => {\n                const data = identifiers.map(identifier => identifier![column.referencedColumn!.databaseName]);\n                return `${escape(column.databaseName)} IN (${data.join(\", \")})`;\n            }).join(\" AND \");\n        };\n\n        const ancestorWhere = generateWheres(closureTable.ancestorColumns);\n        const descendantWhere = generateWheres(closureTable.descendantColumns);\n\n        await this.queryRunner\n            .manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(ancestorWhere)\n            .orWhere(descendantWhere)\n            .execute();\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath.split(\".\")\n            .map(i => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n            }).join(\".\");\n    }\n}"],"sourceRoot":"../.."}