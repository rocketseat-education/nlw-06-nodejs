{"version":3,"sources":["../browser/src/metadata/ColumnMetadata.ts"],"names":[],"mappings":"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","file":"ColumnMetadata.js","sourcesContent":["import {ColumnType} from \"../driver/types/ColumnTypes\";\nimport {EntityMetadata} from \"./EntityMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\nimport {RelationMetadata} from \"./RelationMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {ColumnMetadataArgs} from \"../metadata-args/ColumnMetadataArgs\";\nimport {Connection} from \"../connection/Connection\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {ValueTransformer} from \"../decorator/options/ValueTransformer\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {FindOperator} from \"../find-options/FindOperator\";\nimport {ApplyValueTransformers} from \"../util/ApplyValueTransformers\";\n\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class where column decorator is used.\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\n     */\n    target: Function|string;\n\n    /**\n     * Entity metadata where this column metadata is.\n     *\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata;\n\n    /**\n     * Embedded metadata where this column metadata is.\n     * If this column is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata;\n\n    /**\n     * If column is a foreign key of some relation then this relation's metadata will be there.\n     * If this column does not have a foreign key then this property value is undefined.\n     */\n    relationMetadata?: RelationMetadata;\n\n    /**\n     * Class's property name on which this column is applied.\n     */\n    propertyName: string;\n\n    /**\n     * The database type of the column.\n     */\n    type: ColumnType;\n\n    /**\n     * Type's length in the database.\n     */\n    length: string = \"\";\n\n    /**\n     * Type's display width in the database.\n     */\n    width?: number;\n\n    /**\n     * Defines column character set.\n     */\n    charset?: string;\n\n    /**\n     * Defines column collation.\n     */\n    collation?: string;\n\n    /**\n     * Indicates if this column is a primary key.\n     */\n    isPrimary: boolean = false;\n\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    isGenerated: boolean = false;\n\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    isNullable: boolean = false;\n\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    isSelect: boolean = true;\n\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    isInsert: boolean = true;\n\n    /**\n     * Indicates if column allows updates or not.\n     */\n    isUpdate: boolean = true;\n\n    /**\n     * Specifies generation strategy if this column will use auto increment.\n     */\n    generationStrategy?: \"uuid\"|\"increment\"|\"rowid\";\n\n    /**\n     * Column comment.\n     * This feature is not supported by all databases.\n     */\n    comment?: string;\n\n    /**\n     * Default database value.\n     */\n    default?: any;\n\n    /**\n     * ON UPDATE trigger. Works only for MySQL.\n     */\n    onUpdate?: string;\n\n    /**\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\n     * which is the maximum number of digits that are stored for the values.\n     */\n    precision?: number|null;\n\n    /**\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\n     */\n    scale?: number;\n\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    zerofill: boolean = false;\n\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    unsigned: boolean = false;\n\n    /**\n     * Array of possible enumerated values.\n     *\n     * `postgres` and `mysql` store enum values as strings but we want to keep support\n     * for numeric and heterogeneous based typescript enums, so we need (string|number)[]\n     */\n    enum?: (string|number)[];\n\n    /**\n     * Exact name of enum\n     */\n    enumName?: string;\n\n    /**\n     * Generated column expression. Supports only in MySQL.\n     */\n    asExpression?: string;\n\n    /**\n     * Generated column type. Supports only in MySQL.\n     */\n    generatedType?: \"VIRTUAL\"|\"STORED\";\n\n    /**\n     * Return type of HSTORE column.\n     * Returns value as string or as object.\n     */\n    hstoreType?: \"object\"|\"string\";\n\n    /**\n     * Indicates if this column is an array.\n     */\n    isArray: boolean = false;\n\n    /**\n     * Gets full path to this column property (including column property name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string;\n\n    /**\n     * Same as property path, but dots are replaced with '_'.\n     * Used in query builder statements.\n     */\n    propertyAliasName: string;\n\n    /**\n     * Gets full path to this column database name (including column database name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just database name of the column.\n     */\n    databasePath: string;\n\n    /**\n     * Complete column name in the database including its embedded prefixes.\n     */\n    databaseName: string;\n\n    /**\n     * Database name in the database without embedded prefixes applied.\n     */\n    databaseNameWithoutPrefixes: string;\n\n    /**\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\n     */\n    givenDatabaseName?: string;\n\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    isVirtual: boolean = false;\n\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    isDiscriminator: boolean = false;\n\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    isTreeLevel: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    isCreateDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    isUpdateDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    isDeleteDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    isVersion: boolean = false;\n\n    /**\n     * Indicates if this column contains an object id.\n     */\n    isObjectId: boolean = false;\n\n    /**\n     * If this column is foreign key then it references some other column,\n     * and this property will contain reference to this column.\n     */\n    referencedColumn: ColumnMetadata|undefined;\n\n    /**\n     * Specifies a value transformer that is to be used to (un)marshal\n     * this column when reading or writing to the database.\n     */\n    transformer?: ValueTransformer|ValueTransformer[];\n\n    /**\n     * Column type in the case if this column is in the closure table.\n     * Column can be ancestor or descendant in the closure tables.\n     */\n    closureType?: \"ancestor\"|\"descendant\";\n\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetLeft: boolean = false;\n\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetRight: boolean = false;\n\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    isMaterializedPath: boolean = false;\n\n    /**\n     * Spatial Feature Type (Geometry, Point, Polygon, etc.)\n     */\n    spatialFeatureType?: string;\n\n    /**\n     * SRID (Spatial Reference ID (EPSG code))\n     */\n    srid?: number;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: Connection,\n        entityMetadata: EntityMetadata,\n        embeddedMetadata?: EmbeddedMetadata,\n        referencedColumn?: ColumnMetadata,\n        args: ColumnMetadataArgs,\n        closureType?: \"ancestor\"|\"descendant\",\n        nestedSetLeft?: boolean,\n        nestedSetRight?: boolean,\n        materializedPath?: boolean,\n    }) {\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata!;\n        this.referencedColumn = options.referencedColumn;\n        if (options.args.target)\n            this.target = options.args.target;\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName;\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name;\n        if (options.args.options.type)\n            this.type = options.args.options.type;\n        if (options.args.options.length)\n            this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n        if (options.args.options.width)\n            this.width = options.args.options.width;\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset;\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation;\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary;\n        if (options.args.options.default === null) // to make sure default: null is the same as nullable: true\n            this.isNullable = true;\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable;\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select;\n        if (options.args.options.insert !== undefined)\n            this.isInsert = options.args.options.insert;\n        if (options.args.options.update !== undefined)\n            this.isUpdate = options.args.options.update;\n        if (options.args.options.readonly !== undefined)\n            this.isUpdate = !options.args.options.readonly;\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment;\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default;\n        if (options.args.options.onUpdate)\n            this.onUpdate = options.args.options.onUpdate;\n        if (options.args.options.scale !== null && options.args.options.scale !== undefined)\n            this.scale = options.args.options.scale;\n        if (options.args.options.zerofill) {\n            this.zerofill = options.args.options.zerofill;\n            this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n        }\n        if (options.args.options.unsigned)\n            this.unsigned = options.args.options.unsigned;\n        if (options.args.options.precision !== null)\n            this.precision = options.args.options.precision;\n        if (options.args.options.enum) {\n            if (options.args.options.enum instanceof Object && !Array.isArray(options.args.options.enum)) {\n                this.enum = Object.keys(options.args.options.enum)\n                    // remove numeric keys - typescript numeric enum types generate them\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n                    // generated SQL statements contains string representation of that function which leads into syntax error\n                    // at database side.\n                    .filter(key => isNaN(+key) && typeof (options.args.options.enum as ObjectLiteral)[key] !== \"function\")\n                    .map(key => (options.args.options.enum as ObjectLiteral)[key]);\n\n            } else {\n                this.enum = options.args.options.enum;\n            }\n        }\n        if (options.args.options.enumName) {\n            this.enumName = options.args.options.enumName;\n        }\n        if (options.args.options.asExpression) {\n            this.asExpression = options.args.options.asExpression;\n            this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : \"VIRTUAL\";\n        }\n        if (options.args.options.hstoreType)\n            this.hstoreType = options.args.options.hstoreType;\n        if (options.args.options.array)\n            this.isArray = options.args.options.array;\n        if (options.args.mode) {\n            this.isVirtual = options.args.mode === \"virtual\";\n            this.isTreeLevel = options.args.mode === \"treeLevel\";\n            this.isCreateDate = options.args.mode === \"createDate\";\n            this.isUpdateDate = options.args.mode === \"updateDate\";\n            this.isDeleteDate = options.args.mode === \"deleteDate\";\n            this.isVersion = options.args.mode === \"version\";\n            this.isObjectId = options.args.mode === \"objectId\";\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer;\n        if (options.args.options.spatialFeatureType)\n            this.spatialFeatureType = options.args.options.spatialFeatureType;\n        if (options.args.options.srid !== undefined)\n            this.srid = options.args.options.srid;\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel;\n        if (this.isCreateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.createDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n        }\n        if (this.isUpdateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.updateDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n            if (!this.onUpdate)\n                this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n        }\n        if (this.isDeleteDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.deleteDate;\n            if (!this.isNullable)\n                this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version;\n        if (options.closureType)\n            this.closureType = options.closureType;\n        if (options.nestedSetLeft)\n            this.isNestedSetLeft = options.nestedSetLeft;\n        if (options.nestedSetRight)\n            this.isNestedSetRight = options.nestedSetRight;\n        if (options.materializedPath)\n            this.isMaterializedPath = options.materializedPath;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any, useDatabaseName = false) {\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n                    return map;\n                }\n\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null)\n                    value = String(value);\n\n                map[useDatabaseName ? this.databaseName : this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, {});\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null)\n                value = String(value);\n\n            return { [useDatabaseName ? this.databaseName : this.propertyName]: value };\n        }\n    }\n\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(entity: ObjectLiteral, options?: { skipNulls?: boolean }): ObjectLiteral|undefined {\n        const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral, map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (value === undefined)\n                    return map;\n\n                if (propertyName) {\n                    const submap: ObjectLiteral = {};\n                    extractEmbeddedColumnValue(propertyNames, value[propertyName], submap);\n                    if (Object.keys(submap).length > 0) {\n                        map[propertyName] = submap;\n                    }\n                    return map;\n                }\n                if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null))\n                    map[this.propertyName] = value[this.propertyName];\n                return map;\n            };\n            const map: ObjectLiteral = {};\n            extractEmbeddedColumnValue(propertyNames, entity, map);\n            return Object.keys(map).length > 0 ? map : undefined;\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n            if (this.relationMetadata && entity[this.relationMetadata.propertyName] && entity[this.relationMetadata.propertyName] instanceof Object) {\n                const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n                    const value = joinColumn.referencedColumn!.getEntityValueMap(entity[this.relationMetadata!.propertyName]);\n                    if (value === undefined) return map;\n                    return OrmUtils.mergeDeep(map, value);\n                }, {});\n                if (Object.keys(map).length > 0)\n                    return { [this.propertyName]: map };\n\n                return undefined;\n            } else {\n                if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null))\n                    return { [this.propertyName]: entity[this.propertyName] };\n\n                return undefined;\n            }\n        }\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(entity: ObjectLiteral, transform: boolean = false): any|undefined {\n        if (entity === undefined || entity === null) return undefined;\n\n        // extract column value from embeddeds of entity if column is in embedded\n        let value: any = undefined;\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\n            };\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn) {\n                    const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n                    if (relatedEntity && relatedEntity instanceof Object && !(relatedEntity instanceof FindOperator)) {\n                        value = this.referencedColumn.getEntityValue(relatedEntity);\n\n                    } else if (embeddedObject[this.propertyName] && embeddedObject[this.propertyName] instanceof Object && !(embeddedObject[this.propertyName] instanceof FindOperator)) {\n                        value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n\n                    } else {\n                        value = embeddedObject[this.propertyName];\n\n                    }\n\n                } else if (this.referencedColumn) {\n                    value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n\n                } else {\n                    value = embeddedObject[this.propertyName];\n                }\n            }\n\n        } else { // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn) {\n                const relatedEntity = this.relationMetadata.getEntityValue(entity);\n                if (relatedEntity && relatedEntity instanceof Object && !(relatedEntity instanceof FindOperator) && !(relatedEntity instanceof Function)) {\n                    value = this.referencedColumn.getEntityValue(relatedEntity);\n\n                } else if (entity[this.propertyName] && entity[this.propertyName] instanceof Object && !(entity[this.propertyName] instanceof FindOperator) && !(entity[this.propertyName] instanceof Function)) {\n                    value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n\n                } else {\n                    value = entity[this.propertyName];\n                }\n\n            } else if (this.referencedColumn) {\n                value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n\n            } else {\n                value = entity[this.propertyName];\n            }\n        }\n\n        if (transform && this.transformer)\n            value = ApplyValueTransformers.transformTo(this.transformer, value);\n\n        return value;\n    }\n\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        if (this.embeddedMetadata) {\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (embeddedMetadatas: EmbeddedMetadata[], map: ObjectLiteral): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift();\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n\n        } else {\n            // we write a deep object in this entity only if the column is virtual\n            // because if its not virtual it means the user defined a real column for this relation\n            // also we don't do it if column is inside a junction table\n            if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {\n                if (!(this.propertyName in entity)) {\n                    entity[this.propertyName] = {};\n                }\n\n                entity[this.propertyName][this.referencedColumn.propertyName] = value;\n            } else {\n                entity[this.propertyName] = value;\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: Connection): this {\n        this.propertyPath = this.buildPropertyPath();\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n        this.databaseName = this.buildDatabaseName(connection);\n        this.databasePath = this.buildDatabasePath();\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n        return this;\n    }\n\n    protected buildPropertyPath(): string {\n        let path = \"\";\n        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n\n        path += this.propertyName;\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)\n            path += \".\" + this.referencedColumn.propertyName;\n\n        return path;\n    }\n\n    protected buildDatabasePath(): string {\n        let path = \"\";\n        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n\n        path += this.databaseName;\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName)\n            path += \".\" + this.referencedColumn.databaseName;\n\n        return path;\n    }\n\n    protected buildDatabaseName(connection: Connection): string {\n        let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n        if (connection.driver instanceof MongoDriver) // we don't need to include embedded name for the mongodb column names\n            propertyNames = [];\n        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n    }\n\n}\n"],"sourceRoot":".."}