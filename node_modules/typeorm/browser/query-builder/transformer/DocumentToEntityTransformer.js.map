{"version":3,"sources":["../browser/src/query-builder/transformer/DocumentToEntityTransformer.ts"],"names":[],"mappings":"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","file":"DocumentToEntityTransformer.js","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {EmbeddedMetadata} from \"../../metadata/EmbeddedMetadata\";\n\n/**\n * Transforms raw document into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class DocumentToEntityTransformer {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(// private selectionMap: AliasMap,\n                // private joinMappings: JoinMapping[],\n                // private relationCountMetas: RelationCountAttribute[],\n                private enableRelationIdValues: boolean = false\n    ) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transformAll(documents: ObjectLiteral[], metadata: EntityMetadata) {\n        return documents.map(document => this.transform(document, metadata));\n    }\n\n    transform(document: any, metadata: EntityMetadata) {\n        const entity: any = metadata.create();\n        let hasData = false;\n\n        // handle _id property the special way\n        if (metadata.objectIdColumn && document[metadata.objectIdColumn.databaseNameWithoutPrefixes]) {\n            // todo: we can't use driver in this class\n            // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?\n            // entity[metadata.objectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.objectIdColumn.name\"], metadata.objectIdColumn);\n            entity[metadata.objectIdColumn.propertyName] = document[metadata.objectIdColumn.databaseNameWithoutPrefixes];\n            hasData = true;\n        }\n\n        // add special columns that contains relation ids\n        if (this.enableRelationIdValues) {\n            metadata.columns.filter(column => !!column.relationMetadata).forEach(column => {\n                const valueInObject = document[column.databaseNameWithoutPrefixes];\n                if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {\n                    // todo: we can't use driver in this class\n                    // const value = this.driver.prepareHydratedValue(valueInObject, column);\n                    entity[column.propertyName] = valueInObject;\n                    hasData = true;\n                }\n            });\n        }\n\n        /*this.joinMappings\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)\n            .map(joinMapping => {\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);\n                const isResultArray = joinMapping.isMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result && (!isResultArray || result.length > 0)) {\n                    entity[joinMapping.propertyName] = result;\n                    hasData = true;\n                }\n            });*/\n\n        // get value from columns selections and put them into object\n        metadata.ownColumns.forEach(column => {\n            const valueInObject = document[column.databaseNameWithoutPrefixes];\n            if (valueInObject !== undefined &&\n                valueInObject !== null &&\n                column.propertyName &&\n                !column.isVirtual) {\n                // const value = this.driver.prepareHydratedValue(valueInObject, column);\n\n                entity[column.propertyName] = valueInObject;\n                hasData = true;\n            }\n        });\n\n        const addEmbeddedValuesRecursively = (entity: any, document: any, embeddeds: EmbeddedMetadata[]) => {\n            embeddeds.forEach(embedded => {\n                if (!document[embedded.prefix])\n                    return;\n\n                if (embedded.isArray) {\n                    entity[embedded.propertyName] = (document[embedded.prefix] as any[]).map((subValue: any, index: number) => {\n                        const newItem = embedded.create();\n                        embedded.columns.forEach(column => {\n                            newItem[column.propertyName] = subValue[column.databaseNameWithoutPrefixes];\n                        });\n                        addEmbeddedValuesRecursively(newItem, document[embedded.prefix][index], embedded.embeddeds);\n                        return newItem;\n                    });\n\n                } else {\n                    if (embedded.embeddeds.length && !entity[embedded.propertyName]) \n                        entity[embedded.propertyName] = embedded.create();\n                    \n                    embedded.columns.forEach(column => {\n                        const value = document[embedded.prefix][column.databaseNameWithoutPrefixes];\n                        if (value === undefined) return;\n\n                        if (!entity[embedded.propertyName])\n                            entity[embedded.propertyName] = embedded.create();\n\n                        entity[embedded.propertyName][column.propertyName] = value;\n                    });\n                }\n                addEmbeddedValuesRecursively(entity[embedded.propertyName], document[embedded.prefix], embedded.embeddeds);\n            });\n        };\n\n        addEmbeddedValuesRecursively(entity, document, metadata.embeddeds);\n\n        // if relation is loaded then go into it recursively and transform its values too\n        /*metadata.relations.forEach(relation => {\n            const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);\n            if (relationAlias) {\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result) {\n                    let propertyName = relation.propertyName;\n                    if (joinMapping) {\n                        propertyName = joinMapping.propertyName;\n                    }\n\n                    if (relation.isLazy) {\n                        entity[\"__\" + propertyName + \"__\"] = result;\n                    } else {\n                        entity[propertyName] = result;\n                    }\n\n                    if (!isResultArray || result.length > 0)\n                        hasData = true;\n                }\n            }\n\n            // if relation has id field then relation id/ids to that field.\n            if (relation.isManyToMany) {\n                if (relationAlias) {\n                    const ids: any[] = [];\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\n\n                    if (relation.idField || joinMapping) {\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\n                        const junctionMetadata = relation.junctionEntityMetadata;\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;\n\n                        rawSqlResults.forEach(results => {\n                            if (relationAlias) {\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\n                                if (value !== undefined && value !== null)\n                                    ids.push(value);\n                            }\n                        });\n\n                        if (ids && ids.length)\n                            entity[propertyName] = ids;\n                    }\n                }\n            } else if (relation.idField) {\n                const relationName = relation.name;\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\n            }\n\n            // if relation counter\n            this.relationCountMetas.forEach(joinMeta => {\n                if (joinMeta.alias === relationAlias) {\n                    // console.log(\"relation count was found for relation: \", relation);\n                    // joinMeta.entity = entity;\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\n                    // console.log(joinMeta);\n                    // console.log(\"---------------------\");\n                }\n            });\n        });*/\n\n        return hasData ? entity : null;\n    }\n\n}\n"],"sourceRoot":"../.."}