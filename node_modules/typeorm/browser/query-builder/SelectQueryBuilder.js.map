{"version":3,"sources":["../browser/src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","file":"SelectQueryBuilder.js","sourcesContent":["import {SapDriver} from \"../driver/sap/SapDriver\";\nimport {RawSqlResultsToEntityTransformer} from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {PessimisticLockTransactionRequiredError} from \"../error/PessimisticLockTransactionRequiredError\";\nimport {NoVersionOrUpdateDateColumnError} from \"../error/NoVersionOrUpdateDateColumnError\";\nimport {OptimisticLockVersionMismatchError} from \"../error/OptimisticLockVersionMismatchError\";\nimport {OptimisticLockCanNotBeUsedError} from \"../error/OptimisticLockCanNotBeUsedError\";\nimport {JoinAttribute} from \"./JoinAttribute\";\nimport {RelationIdAttribute} from \"./relation-id/RelationIdAttribute\";\nimport {RelationCountAttribute} from \"./relation-count/RelationCountAttribute\";\nimport {RelationIdLoader} from \"./relation-id/RelationIdLoader\";\nimport {RelationIdMetadataToAttributeTransformer} from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport {RelationCountLoader} from \"./relation-count/RelationCountLoader\";\nimport {RelationCountMetadataToAttributeTransformer} from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport {QueryBuilder} from \"./QueryBuilder\";\nimport {ReadStream} from \"../platform/PlatformTools\";\nimport {LockNotSupportedOnGivenDriverError} from \"../error/LockNotSupportedOnGivenDriverError\";\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {SelectQuery} from \"./SelectQuery\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {WhereExpression} from \"./WhereExpression\";\nimport {Brackets} from \"./Brackets\";\nimport {AbstractSqliteDriver} from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport {QueryResultCacheOptions} from \"../cache/QueryResultCacheOptions\";\nimport {OffsetWithoutLimitNotSupportedError} from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\nimport {SelectQueryBuilderOption} from \"./SelectQueryBuilderOption\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\nimport {DriverUtils} from \"../driver/DriverUtils\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport {CockroachDriver} from \"../driver/cockroachdb/CockroachDriver\";\nimport {EntityNotFoundError} from \"../error/EntityNotFoundError\";\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity> extends QueryBuilder<Entity> implements WhereExpression {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment();\n        sql += this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitOffsetExpression();\n        sql += this.createLockExpression();\n        sql = sql.trim();\n        if (this.expressionMap.subQuery)\n            sql = \"(\" + sql + \")\";\n        return sql;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder();\n        qb.expressionMap.subQuery = true;\n        qb.expressionMap.parentQueryBuilder = this;\n        return qb;\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this;\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, selectionAliasName?: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection?: string|string[]|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), selectionAliasName?: string): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map(selection => ({ selection: selection }));\n\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });\n\n        } else if (selection) {\n            this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string|string[]|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), selectionAliasName?: string): this {\n        if (!selection)\n            return this;\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({ selection: selection })));\n\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });\n\n        } else if (selection) {\n            this.expressionMap.selects.push({ selection: selection, aliasName: selectionAliasName });\n        }\n\n        return this;\n    }\n\n    /**\n     * Set max execution time.\n     * @param milliseconds\n     */\n    maxExecutionTime(milliseconds: number): this {\n        this.expressionMap.maxExecutionTime = milliseconds;\n        return this;\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct;\n        return this;\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn;\n        return this;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(entityTarget: EntityTarget<T>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(entityTarget: EntityTarget<T>|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName);\n        this.expressionMap.setMainAlias(mainAlias);\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(entityTarget: EntityTarget<T>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(entityTarget: EntityTarget<T>|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName);\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias);\n\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entity: Function|string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entity: Function|string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entity: Function|string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.innerJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.leftJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n        return this;\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, options?: { disableMixedMap?: boolean }): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, alias: string, queryBuilderFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string,\n                         relationName: string,\n                         aliasNameOrOptions?: string|{ disableMixedMap?: boolean },\n                         queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\n\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n        relationIdAttribute.mapToProperty = mapToProperty;\n        relationIdAttribute.relationName = relationName;\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions;\n        if (aliasNameOrOptions instanceof Object && (aliasNameOrOptions as any).disableMixedMap)\n            relationIdAttribute.disableMixedMap = true;\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(mapToProperty: string, relationName: string, aliasName?: string, queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\n        const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n        relationCountAttribute.mapToProperty = mapToProperty;\n        relationCountAttribute.relationName = relationName;\n        relationCountAttribute.alias = aliasName;\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias\n        });\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata: relationCountAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: { relations?: string[], disableMixedMap?: boolean }): this { // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach(relation => {\n            if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1)\n                return;\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\n                options\n            );\n        });\n        return this;\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(where: Brackets|string|((qb: this) => string)|ObjectLiteral|ObjectLiteral[], parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.computeWhereParameter(where);\n        if (condition)\n            this.expressionMap.wheres = [{ type: \"simple\", condition: condition }];\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(where: string|Brackets|((qb: this) => string), parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"and\", condition: this.computeWhereParameter(where) });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(where: Brackets|string|((qb: this) => string), parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"or\", condition: this.computeWhereParameter(where) });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any|any[]): this {\n        return this.where(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any|any[]): this {\n        return this.andWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any|any[]): this {\n        return this.orWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy];\n        } else {\n            this.expressionMap.groupBys = [];\n        }\n        return this;\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy);\n        return this;\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort: string, order?: \"ASC\"|\"DESC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort?: string|OrderByCondition, order: \"ASC\"|\"DESC\" = \"ASC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n        if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n\n        if (sort) {\n            if (sort instanceof Object) {\n                this.expressionMap.orderBys = sort as OrderByCondition;\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = { [sort as string]: { order, nulls } };\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order };\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(sort: string, order: \"ASC\"|\"DESC\" = \"ASC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n        if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls };\n        } else {\n            this.expressionMap.orderBys[sort] = order;\n        }\n        return this;\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit);\n        if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit))\n            throw new Error(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset);\n        if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset))\n            throw new Error(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take);\n        if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take))\n            throw new Error(`Provided \"take\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip);\n        if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip))\n            throw new Error(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"pessimistic_read\"|\"pessimistic_write\"|\"dirty_read\"|\"pessimistic_partial_write\"|\"pessimistic_write_or_fail\"|\"for_no_key_update\", lockVersion?: undefined, lockTables?: string[]): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\"|\"pessimistic_read\"|\"pessimistic_write\"|\"dirty_read\"|\"pessimistic_partial_write\"|\"pessimistic_write_or_fail\"|\"for_no_key_update\", lockVersion?: number|Date, lockTables?: string[]): this {\n        this.expressionMap.lockMode = lockMode;\n        this.expressionMap.lockVersion = lockVersion;\n        this.expressionMap.lockTables = lockTables;\n        return this;\n    }\n\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted(): this {\n        this.expressionMap.withDeleted = true;\n        return this;\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne<T = any>(): Promise<T> {\n        return (await this.getRawMany())[0];\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany<T = any>(): Promise<T[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        this.expressionMap.queryEntity = false;\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const results = await this.loadRawResults(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) { // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities<T = any>(): Promise<{ entities: Entity[], raw: T[] }> {\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            const results = await this.executeEntitiesAndRawResults(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity|undefined> {\n        const results = await this.getRawAndEntities();\n        const result = results.entities[0] as any;\n\n        if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion = metadata.updateDateColumn!.getEntityValue(result); // what if columns arent set?\n                if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n\n            } else {\n                const actualVersion = metadata.versionColumn!.getEntityValue(result); // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail(): Promise<Entity> {\n        const entity = await this.getOne();\n\n        if (!entity) {\n            throw new EntityNotFoundError(this.expressionMap.mainAlias!.target, this);\n        }\n\n        return entity;\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const results = await this.getRawAndEntities();\n        return results.entities;\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = false;\n            const results = await this.executeCountQuery(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);\n            this.expressionMap.queryEntity = false;\n            const count = await this.executeCountQuery(queryRunner);\n            const results: [Entity[], number] = [entitiesAndRaw.entities, count];\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false;\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner) // means we created our own query runner\n                    return queryRunner.release();\n                return;\n            };\n            const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this;\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this;\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this;\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabledOrMillisecondsOrId: boolean|number|string, maybeMilliseconds?: number): this {\n\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId;\n\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n\n        } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option);\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(direction: \"INNER\"|\"LEFT\",\n                   entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n                   aliasName: string,\n                   condition?: string,\n                   parameters?: ObjectLiteral,\n                   mapToProperty?: string,\n                   isMappingMany?: boolean): void {\n\n        this.setParameters(parameters || {});\n\n        const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n        joinAttribute.direction = direction;\n        joinAttribute.mapToProperty = mapToProperty;\n        joinAttribute.isMappingMany = isMappingMany;\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\n        joinAttribute.condition = condition; // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute);\n\n        if (joinAttribute.metadata) {\n           if (joinAttribute.metadata.deleteDateColumn && !this.expressionMap.withDeleted) {\n                const conditionDeleteColumn = `${aliasName}.${joinAttribute.metadata.deleteDateColumn.propertyName} IS NULL`;\n                joinAttribute.condition += joinAttribute.condition ? ` AND ${conditionDeleteColumn}`: `${conditionDeleteColumn}`;\n            }\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttribute.metadata\n            });\n            if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata\n                });\n            }\n\n        } else {\n            let subQuery: string = \"\";\n            if (entityOrProperty instanceof Function) {\n                const subQueryBuilder: SelectQueryBuilder<any> = (entityOrProperty as any)(((this as any) as SelectQueryBuilder<any>).subQuery());\n                this.setParameters(subQueryBuilder.getParameters());\n                subQuery = subQueryBuilder.getQuery();\n\n            } else {\n                subQuery = entityOrProperty;\n            }\n            const isSubQuery = entityOrProperty instanceof Function || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath: isSubQuery === false ? entityOrProperty as string : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            });\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\"Cannot build query because main alias is not set (call qb#from method)\");\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = [];\n        const excludedSelects: SelectQuery[] = [];\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n            excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes\n            .forEach(join => {\n                if (join.metadata) {\n                    allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name!, join.metadata));\n                    excludedSelects.push(...this.findEntityColumnSelects(join.alias.name!, join.metadata));\n                } else {\n                    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\n                    if (hasMainAlias) {\n                        allSelects.push({ selection: this.escape(join.alias.name!) + \".*\" });\n                        const excludedSelect = this.expressionMap.selects.find(select => select.selection === join.alias.name);\n                        excludedSelects.push(excludedSelect!);\n                    }\n                }\n            });\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter(select => excludedSelects.indexOf(select) === -1)\n            .forEach(select => allSelects.push({ selection: this.replacePropertyNames(select.selection), aliasName: select.aliasName }));\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0)\n            allSelects.push({ selection: \"*\" });\n\n        let lock: string = \"\";\n        if (this.connection.driver instanceof SqlServerDriver) {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    lock = \" WITH (HOLDLOCK, ROWLOCK)\";\n                    break;\n                case \"pessimistic_write\":\n                    lock = \" WITH (UPDLOCK, ROWLOCK)\";\n                    break;\n                case \"dirty_read\":\n                    lock = \" WITH (NOLOCK)\";\n                    break;\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(alias => alias.type === \"from\" && (alias.tablePath || alias.subQuery))\n            .map(alias => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name);\n\n                return this.getTableName(alias.tablePath!) + \" \" + this.escape(alias.name);\n            });\n\n        const select = this.createSelectDistinctExpression();\n        const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\n\n        return select + selection + \" FROM \" + froms.join(\", \") + lock;\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const {selectDistinct, selectDistinctOn, maxExecutionTime} = this.expressionMap;\n        const {driver} = this.connection;\n\n        let select = \"SELECT \";\n\n        if (maxExecutionTime > 0) {\n            if (driver instanceof MysqlDriver) {\n                select += `/*+ MAX_EXECUTION_TIME(${ this.expressionMap.maxExecutionTime }) */ `;\n            }\n        }\n\n        if (driver instanceof PostgresDriver && selectDistinctOn.length > 0) {\n            const selectDistinctOnMap = selectDistinctOn.map(\n              (on) => this.replacePropertyNames(on)\n            ).join(\", \");\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \";\n        }\n\n        return select;\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n            const relation = joinAttr.relation;\n            const destinationTableName = joinAttr.tablePath;\n            const destinationTableAlias = joinAttr.alias.name;\n            let appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n            const parentAlias = joinAttr.parentAlias;\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);\n                return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + this.escape(destinationTableAlias) +\n                    (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns.map(joinColumn => {\n                    return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\n                        parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation.inverseRelation!.joinColumns.map(joinColumn => {\n                    if (relation.inverseEntityMetadata.tableType === \"entity-child\" && relation.inverseEntityMetadata.discriminatorColumn) {\n                        appendedCondition += \" AND \" + destinationTableAlias + \".\" + relation.inverseEntityMetadata.discriminatorColumn.databaseName + \"='\" + relation.inverseEntityMetadata.discriminatorValue + \"'\";\n                    }\n\n                    return destinationTableAlias + \".\" + relation.inverseRelation!.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\n                        parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n\n            } else { // means many-to-many\n                const junctionTableName = relation.junctionEntityMetadata!.tablePath;\n\n                const junctionAlias = joinAttr.junctionAlias;\n                let junctionCondition = \"\", destinationCondition = \"\";\n\n                if (relation.isOwning) {\n\n                    junctionCondition = relation.joinColumns.map(joinColumn => {\n                        // `post_category`.`postId` = `post`.`id`\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                    }).join(\" AND \");\n\n                    destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\n                        // `category`.`id` = `post_category`.`categoryId`\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n                    }).join(\" AND \");\n\n                } else {\n                    junctionCondition = relation.inverseRelation!.inverseJoinColumns.map(joinColumn => {\n                        // `post_category`.`categoryId` = `category`.`id`\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                    }).join(\" AND \");\n\n                    destinationCondition = relation.inverseRelation!.joinColumns.map(joinColumn => {\n                        // `post`.`id` = `post_category`.`postId`\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n                    }).join(\" AND \");\n                }\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(junctionTableName) + \" \" + this.escape(junctionAlias) + \" ON \" + this.replacePropertyNames(junctionCondition) +\n                    \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\n\n            }\n        });\n\n        return joins.join(\" \");\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n        return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys;\n        if (Object.keys(orderBys).length > 0)\n            return \" ORDER BY \" + Object.keys(orderBys)\n                    .map(columnName => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n                        } else {\n                            return this.replacePropertyNames(columnName) + \" \" + (orderBys[columnName] as any).order + \" \" + (orderBys[columnName] as any).nulls;\n                        }\n                    })\n                    .join(\", \");\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number|undefined = this.expressionMap.offset,\n            limit: number|undefined = this.expressionMap.limit;\n        if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\n            offset = this.expressionMap.skip;\n            limit = this.expressionMap.take;\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\";\n            if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n                prefix = \" ORDER BY (SELECT NULL)\";\n            }\n\n            if (limit && offset)\n                return prefix + \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (limit)\n                return prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset)\n                return prefix + \" OFFSET \" + offset + \" ROWS\";\n\n        } else if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver || this.connection.driver instanceof SapDriver) {\n\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                throw new OffsetWithoutLimitNotSupportedError();\n\n        } else if (this.connection.driver instanceof AbstractSqliteDriver) {\n\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                return \" LIMIT -1 OFFSET \" + offset;\n\n        } else if (this.connection.driver instanceof OracleDriver) {\n\n            if (limit && offset)\n                return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (limit)\n                return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset)\n                return \" OFFSET \" + offset + \" ROWS\";\n\n        } else {\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                return \" OFFSET \" + offset;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver;\n\n        let lockTablesClause = \"\";\n\n        if (this.expressionMap.lockTables) {\n            if (!(driver instanceof PostgresDriver)) {\n                throw new Error(\"Lock tables not supported in selected driver\");\n            }\n            if (this.expressionMap.lockTables.length < 1) {\n                throw new Error(\"lockTables cannot be an empty array\");\n            }\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n        }\n\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver) {\n                    return \" LOCK IN SHARE MODE\";\n\n                } else if (driver instanceof PostgresDriver) {\n                    return \" FOR SHARE\" + lockTablesClause;\n\n                } else if (driver instanceof OracleDriver) {\n                    return \" FOR UPDATE\";\n\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write\":\n                if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver || driver instanceof OracleDriver) {\n                    return \" FOR UPDATE\";\n\n                }\n                else if (driver instanceof PostgresDriver ) {\n                    return \" FOR UPDATE\" + lockTablesClause;\n\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_partial_write\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n\n                } else if (driver instanceof MysqlDriver) {\n                    return \" FOR UPDATE SKIP LOCKED\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write_or_fail\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n\n                } else if (driver instanceof MysqlDriver) {\n                    return \" FOR UPDATE NOWAIT\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n\n            case \"for_no_key_update\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR NO KEY UPDATE\" + lockTablesClause;\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n        const conditions = this.expressionMap.havings.map((having, index) => {\n            switch (having.type) {\n                case \"and\":\n                    return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\n                case \"or\":\n                    return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\n                default:\n                    return this.replacePropertyNames(having.condition);\n            }\n        }).join(\" \");\n\n        if (!conditions.length) return \"\";\n        return \" HAVING \" + conditions;\n    }\n\n    protected buildEscapedEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\n\n        const columns: ColumnMetadata[] = [];\n        if (hasMainAlias) {\n            columns.push(...metadata.columns.filter(column => column.isSelect === true));\n        }\n        columns.push(...metadata.columns.filter(column => {\n            return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyPath);\n        }));\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0) // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return [];\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n\n        return allColumns.map(column => {\n            const selection = this.expressionMap.selects.find(select => select.selection === aliasName + \".\" + column.propertyPath);\n            let selectionPath = this.escape(aliasName) + \".\" + this.escape(column.databaseName);\n            if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n                    const useLegacy = this.connection.driver.options.legacySpatialSupport;\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n                    selectionPath = `${asText}(${selectionPath})`;\n                }\n\n                if (this.connection.driver instanceof PostgresDriver)\n                    // cast to JSON to trigger parsing in the driver\n                    if (column.precision) {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;\n                    } else {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n                    }\n                if (this.connection.driver instanceof SqlServerDriver)\n                    selectionPath = `${selectionPath}.ToString()`;\n            }\n            return {\n                selection: selectionPath,\n                aliasName: selection && selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(this.connection.driver, aliasName, column.databaseName),\n                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                virtual: selection ? selection.virtual === true : (hasMainAlias ? false : true),\n            };\n        });\n    }\n\n    protected findEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\n        if (mainSelect)\n            return [mainSelect];\n\n        return this.expressionMap.selects.filter(select => {\n            return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyPath);\n        });\n    }\n\n    private computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias!.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        const primaryColumns = metadata.primaryColumns;\n        const distinctAlias = this.escape(mainAlias);\n\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (\n            this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0\n        ) {\n            return \"COUNT(1)\";\n        }\n\n        // For everything else, we'll need to do some hackery to get the correct count values.\n\n        if (this.connection.driver instanceof CockroachDriver || this.connection.driver instanceof PostgresDriver) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return \"COUNT(DISTINCT(\" +\n                primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") +\n                \"))\";\n        }\n\n        if (this.connection.driver instanceof MysqlDriver) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return \"COUNT(DISTINCT \" +\n                primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") +\n                \")\";\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n\n            const columnsExpression = primaryColumns.map(\n                primaryColumn => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`\n            ).join(\", '|;|', \");\n\n            if (primaryColumns.length === 1) {\n\n                return `COUNT(DISTINCT(${columnsExpression}))`;\n            }\n\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n\n        }\n\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n\n        return `COUNT(DISTINCT(` +\n            primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\" || '|;|' || \") +\n            \"))\";\n    }\n\n    protected async executeCountQuery(queryRunner: QueryRunner): Promise<number> {\n        const countSql = this.computeCountExpression();\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner);\n\n        if (!results || !results[0] || !results[0][\"cnt\"])\n            return 0;\n\n        return parseInt(results[0][\"cnt\"]);\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(queryRunner: QueryRunner): Promise<{ entities: Entity[], raw: any[] }> {\n\n        if (!this.expressionMap.mainAlias)\n            throw new Error(`Alias is not set. Use \"from\" method to set an alias.`);\n\n        if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\" || this.expressionMap.lockMode === \"pessimistic_partial_write\" || this.expressionMap.lockMode === \"pessimistic_write_or_fail\" || this.expressionMap.lockMode === \"for_no_key_update\") && !queryRunner.isTransactionActive)\n            throw new PessimisticLockTransactionRequiredError();\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name);\n        }\n\n        const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\n        const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\n        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n        relationIdMetadataTransformer.transform();\n        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n        relationCountMetadataTransformer.transform();\n\n        let rawResults: any[] = [], entities: any[] = [];\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {\n\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n            const metadata = this.expressionMap.mainAlias.metadata;\n            const mainAliasName = this.expressionMap.mainAlias.name;\n\n            const querySelects = metadata.primaryColumns.map(primaryColumn => {\n                const distinctAlias = this.escape(\"distinctAlias\");\n                const columnAlias = this.escape(DriverUtils.buildAlias(this.connection.driver, mainAliasName, primaryColumn.databaseName));\n                if (!orderBys[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction\n                    orderBys[columnAlias] = \"ASC\";\n\n                const alias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    \"ids_\" + mainAliasName,\n                    primaryColumn.databaseName\n                );\n\n                return `${distinctAlias}.${columnAlias} as \"${alias}\"`;\n            });\n\n            rawResults = await new SelectQueryBuilder(this.connection, queryRunner)\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(`(${this.clone().orderBy().getQuery()})`, \"distinctAlias\")\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(this.expressionMap.cache ? this.expressionMap.cache : this.expressionMap.cacheId, this.expressionMap.cacheDuration)\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany();\n\n            if (rawResults.length > 0) {\n                let condition = \"\";\n                const parameters: ObjectLiteral = {};\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults.map((result, index) => {\n                        return metadata.primaryColumns.map(primaryColumn => {\n                            const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n                            parameters[paramKey] = result[`ids_${mainAliasName}_${primaryColumn.databaseName}`];\n                            return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n                        }).join(\" AND \");\n                    }).join(\" OR \");\n                } else {\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        \"ids_\" + mainAliasName,\n                        metadata.primaryColumns[0].databaseName\n                    );\n\n                    const ids = rawResults.map(result => result[alias]);\n                    const areAllNumbers = ids.every((id: any) => typeof id === \"number\");\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(\", \")})`;\n                    } else {\n                        parameters[\"orm_distinct_ids\"] = ids;\n                        condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyPath + \" IN (:...orm_distinct_ids)\";\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({ extraAppendedAndWhereCondition: condition })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner);\n            }\n\n        } else {\n            rawResults = await this.loadRawResults(queryRunner);\n        }\n\n        if (rawResults.length > 0) {\n\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(rawResults);\n            const rawRelationCountResults = await relationCountLoader.load(rawResults);\n            const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);\n            entities = transformer.transform(rawResults, this.expressionMap.mainAlias!);\n\n            // broadcast all \"after load\" events\n            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n                const broadcastResult = new BroadcasterResult();\n                queryRunner.broadcaster.broadcastLoadEventsForAll(broadcastResult, this.expressionMap.mainAlias.metadata, entities);\n                if (broadcastResult.promises.length > 0) await Promise.all(broadcastResult.promises);\n            }\n        }\n\n        return {\n            raw: rawResults,\n            entities: entities,\n        };\n    }\n\n    protected createOrderByCombinedWithSelectExpression(parentAlias: string): [ string, OrderByCondition] {\n\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys;\n        const selectString = Object.keys(orderBys)\n            .map(orderCriteria => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const criteriaParts = orderCriteria.split(\".\");\n                    const aliasName = criteriaParts[0];\n                    const propertyPath = criteriaParts.slice(1).join(\".\");\n                    const alias = this.expressionMap.findAliasByName(aliasName);\n                    const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                    return this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, aliasName, column!.databaseName));\n                } else {\n                    if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria))\n                        return this.escape(parentAlias) + \".\" + orderCriteria;\n\n                    return \"\";\n                }\n            })\n            .join(\", \");\n\n        const orderByObject: OrderByCondition = {};\n        Object.keys(orderBys).forEach(orderCriteria => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\");\n                const aliasName = criteriaParts[0];\n                const propertyPath = criteriaParts.slice(1).join(\".\");\n                const alias = this.expressionMap.findAliasByName(aliasName);\n                const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                orderByObject[this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, aliasName, column!.databaseName))] = orderBys[orderCriteria];\n            } else {\n                if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) {\n                    orderByObject[this.escape(parentAlias) + \".\" + orderCriteria] = orderBys[orderCriteria];\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria];\n                }\n            }\n        });\n\n        return [selectString, orderByObject];\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n        const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n        let savedQueryResultCacheOptions: QueryResultCacheOptions|undefined = undefined;\n        let cacheError = false;\n        if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\n            try {\n                savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\n                }, queryRunner);\n                if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions))\n                    return JSON.parse(savedQueryResultCacheOptions.result);\n            } catch(error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error;\n                }\n                cacheError = true;\n            }\n        }\n\n        const results = await queryRunner.query(sql, parameters);\n\n        if (!cacheError && this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\n            try {\n                await this.connection.queryResultCache.storeInCache({\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    time: new Date().getTime(),\n                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\n                    result: JSON.stringify(results)\n                }, savedQueryResultCacheOptions, queryRunner);\n            } catch(error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error;\n                }\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(expressionMap: Partial<QueryExpressionMap>): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap);\n        return this;\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num;\n\n        return Number(num);\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n    }\n\n}\n"],"sourceRoot":".."}