{"version":3,"sources":["../browser/src/persistence/SubjectDatabaseEntityLoader.ts"],"names":[],"mappings":"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","file":"SubjectDatabaseEntityLoader.js","sourcesContent":["import {Subject} from \"./Subject\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner,\n                protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(operationType: \"save\"|\"remove\"|\"soft-remove\"|\"recover\"): Promise<void> {\n\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\n\n            // prepare entity ids of the subjects we need to load\n            const allIds: ObjectLiteral[] = [];\n            const allSubjects: Subject[] = [];\n            subjectGroup.subjects.forEach(subject => {\n\n                // we don't load if subject already has a database entity loaded\n                if (subject.databaseEntity || !subject.identifier)\n                    return;\n\n                allIds.push(subject.identifier);\n                allSubjects.push(subject);\n            });\n\n            // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n            if (!allIds.length)\n                return;\n\n            const loadRelationPropertyPaths: string[] = [];\n\n            // for the save, soft-remove and recover operation\n            // extract all property paths of the relations we need to load relation ids for\n            // this is for optimization purpose - this way we don't load relation ids for entities\n            // whose relations are undefined, and since they are undefined its really pointless to\n            // load something for them, since undefined properties are skipped by the orm\n            if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n                subjectGroup.subjects.forEach(subject => {\n\n                    // gets all relation property paths that exist in the persisted entity.\n                    subject.metadata.relations.forEach(relation => {\n                        const value = relation.getEntityValue(subject.entityWithFulfilledIds!);\n                        if (value === undefined)\n                            return;\n\n                        if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1)\n                            loadRelationPropertyPaths.push(relation.propertyPath);\n                    });\n                });\n            } else { // remove\n\n                // for remove operation\n                // we only need to load junction relation ids since only they are removed by cascades\n                loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n            }\n\n            const findOptions: FindManyOptions<any> = {\n                loadEagerRelations: false,\n                loadRelationIds: {\n                    relations: loadRelationPropertyPaths,\n                    disableMixedMap: true\n                },\n                // the soft-deleted entities should be included in the loaded entities for recover operation\n                withDeleted: true\n            };\n\n            // load database entities for all given ids\n            const entities = await this.queryRunner.manager\n                .getRepository<ObjectLiteral>(subjectGroup.target)\n                .findByIds(allIds, findOptions);\n\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subjects\n            entities.forEach(entity => {\n                const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);\n                subjects.forEach(subject => {\n                  subject.databaseEntity = entity;\n                  if (!subject.identifier)\n                      subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n                });\n            });\n\n            // this way we tell what subjects we tried to load database entities of\n            for (let subject of allSubjects) {\n                subject.databaseEntityLoaded = true;\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subjects where entity like given subject's entity.\n     * Comparision made by entity id.\n     * Multiple subjects may be returned if duplicates are present in the subject array.\n     * This will likely result in the same row being updated multiple times during a transaction.\n     */\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject[] {\n        return this.subjects.filter(subject => {\n            if (!subject.entity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds!, entity);\n        });\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(group => group.target === operatedEntity.metadata.target);\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\n    }\n\n}\n"],"sourceRoot":".."}