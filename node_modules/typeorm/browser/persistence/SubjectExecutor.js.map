{"version":3,"sources":["../browser/src/persistence/SubjectExecutor.ts"],"names":[],"mappings":"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","file":"SubjectExecutor.js","sourcesContent":["import {SapDriver} from \"../driver/sap/SapDriver\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Subject} from \"./Subject\";\nimport {SubjectTopoligicalSorter} from \"./SubjectTopoligicalSorter\";\nimport {SubjectChangedColumnsComputer} from \"./SubjectChangedColumnsComputer\";\nimport {SubjectWithoutIdentifierError} from \"../error/SubjectWithoutIdentifierError\";\nimport {SubjectRemovedAndUpdatedError} from \"../error/SubjectRemovedAndUpdatedError\";\nimport {MongoQueryRunner} from \"../driver/mongodb/MongoQueryRunner\";\nimport {MongoEntityManager} from \"../entity-manager/MongoEntityManager\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {NestedSetSubjectExecutor} from \"./tree/NestedSetSubjectExecutor\";\nimport {ClosureSubjectExecutor} from \"./tree/ClosureSubjectExecutor\";\nimport {MaterializedPathSubjectExecutor} from \"./tree/MaterializedPathSubjectExecutor\";\nimport {OrmUtils} from \"../util/OrmUtils\";\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner;\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions;\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[];\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be soft-removed.\n     */\n    protected softRemoveSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be recovered.\n     */\n    protected recoverSubjects: Subject[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(queryRunner: QueryRunner, subjects: Subject[], options?: SaveOptions & RemoveOptions) {\n        this.queryRunner = queryRunner;\n        this.allSubjects = subjects;\n        this.options = options;\n        this.validate();\n        this.recompute();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult | undefined = undefined;\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach(subject => subject.recompute());\n            this.updateSubjects.forEach(subject => subject.recompute());\n            this.removeSubjects.forEach(subject => subject.recompute());\n            this.softRemoveSubjects.forEach(subject => subject.recompute());\n            this.recoverSubjects.forEach(subject => subject.recompute());\n            this.recompute();\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n        await this.executeInsertOperations();\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations();\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n        await this.executeRemoveOperations();\n        // console.timeEnd(\".removal\");\n\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations();\n\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n\n        // execute recover operations\n        await this.executeRecoverOperations();\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        await this.updateSpecialColumnsInPersistedEntities();\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach(subject => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject);\n        });\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects);\n        this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n        this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n        this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n        this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        return result;\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        return result;\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName];\n\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps: ObjectLiteral[] = [];\n            const bulkInsertSubjects: Subject[] = [];\n            const singleInsertSubjects: Subject[] = [];\n            if (this.queryRunner.connection.driver instanceof MongoDriver) {\n                subjects.forEach(subject => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n                    }\n\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n                    }\n\n                    subject.createValueSetAndPopChangeMap();\n\n                    bulkInsertSubjects.push(subject);\n                    bulkInsertMaps.push(subject.entity!);\n                });\n            } else if (this.queryRunner.connection.driver instanceof OracleDriver) {\n                subjects.forEach(subject => {\n                    singleInsertSubjects.push(subject);\n                });\n            } else {\n                subjects.forEach(subject => {\n\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver instanceof OracleDriver ||\n                        this.queryRunner.connection.driver instanceof SapDriver) {\n                        singleInsertSubjects.push(subject);\n\n                    } else {\n                        bulkInsertSubjects.push(subject);\n                        bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n                    }\n                });\n            }\n\n            // for mongodb we have a bit different insertion logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                const insertResult = await manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index];\n                    subject.generatedMap = insertResult.generatedMaps[index];\n                    subject.insertedValueSet = bulkInsertMaps[index];\n                });\n\n            } else {\n\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner\n                        .manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(this.options && this.options.reload === false ? false : true)\n                        .callListeners(false)\n                        .execute();\n\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index];\n                        subject.generatedMap = insertResult.generatedMaps[index];\n                        subject.insertedValueSet = bulkInsertMaps[index];\n                    });\n                }\n\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\n\n                        await this.queryRunner\n                            .manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(this.options && this.options.reload === false ? false : true)\n                            .callListeners(false)\n                            .execute()\n                            .then(insertResult => {\n                                subject.identifier = insertResult.identifiers[0];\n                                subject.generatedMap = insertResult.generatedMaps[0];\n                            });\n\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\n\n                        } else if (subject.metadata.treeType === \"materialized-path\") {\n                            await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\n                        }\n                    }\n                }\n            }\n\n            subjects.forEach(subject => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n            });\n        }\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        const updateSubject = async (subject: Subject) => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                const updateMap: ObjectLiteral = subject.createValueSetAndPopChangeMap();\n\n                // for tree tables we execute additional queries\n                switch (subject.metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n\n                    case \"materialized-path\":\n                        await new MaterializedPathSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n                }\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await updateQueryBuilder.execute();\n                let updateGeneratedMap = updateResult.generatedMaps[0];\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(updateGeneratedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(updateGeneratedMap!, preparedValue);\n                        }\n                    });\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {};\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap);\n                }\n            }\n        };\n\n        // Nested sets need to be updated one by one\n        // Split array in two, one with nested set subjects and the other with the remaining subjects\n        const nestedSetSubjects: Subject[] = [];\n        const remainingSubjects: Subject[] = [];\n\n        for (const subject of this.updateSubjects) {\n            if (subject.metadata.treeType === \"nested-set\") {\n                nestedSetSubjects.push(subject);\n            } else {\n                remainingSubjects.push(subject);\n            }\n        }\n\n        // Run nested set updates one by one\n        const nestedSetPromise = new Promise<void>(async (resolve, reject) => {\n            for (const subject of nestedSetSubjects) {\n                try {\n                    await updateSubject(subject);\n                } catch (error) {\n                    reject(error);\n                }\n            }\n            resolve();\n        });\n\n        // Run all remaning subjects in parallel\n        await Promise.all([...remainingSubjects.map(updateSubject), nestedSetPromise]);\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName];\n            const deleteMaps = subjects.map(subject => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject);\n\n                return subject.identifier;\n            });\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                await manager.delete(subjects[0].metadata.target, deleteMaps);\n\n            } else {\n                // for tree tables we execute additional queries\n                switch (subjects[0].metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(this.queryRunner).remove(subjects);\n                        break;\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(this.queryRunner).remove(subjects);\n                        break;\n                }\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute();\n            }\n        }\n    }\n\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    protected async executeSoftRemoveOperations(): Promise<void> {\n        await Promise.all(this.softRemoveSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                // here we execute our soft-deletion query\n                // we need to enable entity soft-deletion because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .softDelete()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await softDeleteQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Recovers all given subjects in the database.\n     */\n    protected async executeRecoverOperations(): Promise<void> {\n        await Promise.all(this.recoverSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                // here we execute our restory query\n                // we need to enable entity restory because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .restore()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await softDeleteQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n\n        // update soft-removed entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);\n\n        // update recovered entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach(subject => {\n                if (!subject.entity) return;\n\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined);\n                });\n            });\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            subject.metadata.relationIds.forEach(relationId => {\n                relationId.setValue(subject.entity!);\n            });\n\n            // mongo _id remove\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                if (subject.metadata.objectIdColumn\n                    && subject.metadata.objectIdColumn.databaseName\n                    && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n                }\n            }\n        });\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(subjects: Subject[]): void {\n        subjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach(column => {\n\n                // if table inheritance is used make sure this column is not child's column\n                if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1)\n                    return;\n\n                // entities does not have virtual columns\n                if (column.isVirtual)\n                    return;\n\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity!);\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity!, null);\n                }\n\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach(updatedRelationMap => {\n                        updatedRelationMap.relation.joinColumns.forEach(column => {\n                            if (column.isVirtual === true)\n                                return;\n\n                            column.setEntityValue(subject.entity!, updatedRelationMap.value instanceof Object ? column.referencedColumn!.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n                        });\n                    });\n                }\n            });\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(subject.metadata.target as any, subject.entity, subject.generatedMap);\n        });\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(subjects: Subject[], type: \"insert\" | \"delete\"): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {};\n        const keys: string[] = [];\n        const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported();\n\n        subjects.forEach((subject, index) => {\n            const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n            if (!group[key]) {\n                group[key] = [subject];\n                keys.push(key);\n            } else {\n                group[key].push(subject);\n            }\n        });\n\n        return [group, keys];\n    }\n\n}\n"],"sourceRoot":".."}