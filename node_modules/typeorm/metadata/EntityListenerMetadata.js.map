{"version":3,"sources":["../../src/metadata/EntityListenerMetadata.ts"],"names":[],"mappings":";;;AAMA;;GAEG;AACH;IAgCI,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,gCAAY,OAAkH;QAC1H,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC;QACjD,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;QAClC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC;QAC9C,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,CAAC;IAED,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;OAEG;IACH,0CAAS,GAAT,UAAU,MAAqB;QAC3B,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,KAAK,MAAM,CAAC,WAAW,IAAI,oIAAoI;YAC5L,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,YAAY,QAAQ,IAAI,MAAM,CAAC,WAAW,CAAC,SAAS,YAAY,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,yDAAyD;IACzL,CAAC;IAED;;OAEG;IACH,wCAAO,GAAP,UAAQ,MAAqB;QACzB,IAAI,CAAC,IAAI,CAAC,gBAAgB;YACtB,OAAO,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC;QAEvC,IAAI,CAAC,wBAAwB,CAAC,MAAM,EAAE,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IACzF,CAAC;IAED,wEAAwE;IACxE,oBAAoB;IACpB,wEAAwE;IAExE;;OAEG;IACO,yDAAwB,GAAlC,UAAmC,MAAqB,EAAE,aAAuB;QAAjF,iBAeC;QAdG,IAAM,YAAY,GAAG,aAAa,CAAC,KAAK,EAAE,CAAC;QAC3C,IAAI,CAAC,YAAY,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC;YACtC,OAAO;QAEX,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,IAAI,MAAM,CAAC,YAAY,CAAC,YAAY,KAAK,EAAE;gBACvC,MAAM,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,UAAC,QAAuB,IAAK,OAAA,QAAQ,CAAC,KAAI,CAAC,YAAY,CAAC,EAAE,EAA7B,CAA6B,CAAC,CAAC;aACxF;iBAAM;gBACH,MAAM,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC;aAC7C;SACJ;aAAM;YACH,IAAI,MAAM,CAAC,YAAY,CAAC;gBACpB,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,aAAa,CAAC,CAAC;SAC1E;IACL,CAAC;IAEL,6BAAC;AAAD,CA1FA,AA0FC,IAAA;AA1FY,wDAAsB","file":"EntityListenerMetadata.js","sourcesContent":["import {EventListenerType} from \"./types/EventListenerTypes\";\nimport {EntityListenerMetadataArgs} from \"../metadata-args/EntityListenerMetadataArgs\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityMetadata} from \"./EntityMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\n\n/**\n * This metadata contains all information about entity's listeners.\n */\nexport class EntityListenerMetadata {\n\n    // ---------------------------------------------------------------------\n    // Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the listener.\n     */\n    entityMetadata: EntityMetadata;\n\n    /**\n     * Embedded metadata of the listener, in the case if listener is in embedded.\n     */\n    embeddedMetadata?: EmbeddedMetadata;\n\n    /**\n     * Target class to which metadata is applied.\n     * This can be different then entityMetadata.target in the case if listener is in the embedded.\n     */\n    target: Function|string;\n\n    /**\n     * Target's property name to which this metadata is applied.\n     */\n    propertyName: string;\n\n    /**\n     * The type of the listener.\n     */\n    type: EventListenerType;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: { entityMetadata: EntityMetadata, embeddedMetadata?: EmbeddedMetadata, args: EntityListenerMetadataArgs }) {\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata;\n        this.target = options.args.target;\n        this.propertyName = options.args.propertyName;\n        this.type = options.args.type;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Checks if entity listener is allowed to be executed on the given entity.\n     */\n    isAllowed(entity: ObjectLiteral) { // todo: create in entity metadata method like isInherited?\n        return this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?\n            (this.entityMetadata.target instanceof Function && entity.constructor.prototype instanceof this.entityMetadata.target); // todo: also need to implement entity schema inheritance\n    }\n\n    /**\n     * Executes listener method of the given entity.\n     */\n    execute(entity: ObjectLiteral) {\n        if (!this.embeddedMetadata)\n            return entity[this.propertyName]();\n\n        this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split(\".\"));\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Calls embedded entity listener method no matter how nested it is.\n     */\n    protected callEntityEmbeddedMethod(entity: ObjectLiteral, propertyPaths: string[]): void {\n        const propertyPath = propertyPaths.shift();\n        if (!propertyPath || !entity[propertyPath])\n            return;\n\n        if (propertyPaths.length === 0) {\n            if (entity[propertyPath] instanceof Array) {\n                entity[propertyPath].map((embedded: ObjectLiteral) => embedded[this.propertyName]());\n            } else {\n                entity[propertyPath][this.propertyName]();\n            }\n        } else {\n            if (entity[propertyPath])\n                this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);\n        }\n    }\n\n}\n"],"sourceRoot":".."}